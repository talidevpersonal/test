/* eslint-disable @typescript-eslint/no-explicit-any */
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import { Provider } from 'react-redux';
import { configureStore, createSlice } from '@reduxjs/toolkit';

/* ======================= hoist-safe mock vars ======================= */
export const mockGetRfi = jest.fn().mockResolvedValue({ status: 'OPEN', requests: [] });
export const mockPostRfiResponse = jest.fn().mockResolvedValue({});
export const mockUploadDocument = jest.fn().mockResolvedValue({ id: 'UP1' });
export const mockDeleteDocument = jest.fn().mockResolvedValue({ success: true });

/* ============================== mocks =============================== */
// useApplicationIdFromUrl
jest.mock('../../hooks/useApplicationIdFromUrl', () => ({
  __esModule: true,
  default: () => 'APP123',
}));

// snackbarContext — define everything INSIDE the factory (no out-of-scope refs)
jest.mock('../../context/snackbarContext', () => {
  const open = jest.fn((msg: string, severity: string = 'info') => {
    const el = document.createElement('div');
    el.textContent = msg;
    el.setAttribute('data-testid', 'snackbar');
    el.setAttribute('data-severity', severity);
    document.body.appendChild(el);
  });
  return {
    __esModule: true,
    useSnackbar: () => open,
  };
});

// services
jest.mock('../../services/rfi.service', () => ({
  __esModule: true,
  default: {
    getRfi: (...a: any[]) => mockGetRfi(...a),
    postRfiResponse: (...a: any[]) => mockPostRfiResponse(...a),
  },
}));
jest.mock('../../services/document.service', () => ({
  __esModule: true,
  default: {
    uploadDocument: (...a: any[]) => mockUploadDocument(...a),
    deleteDocument: (...a: any[]) => mockDeleteDocument(...a),
  },
}));

// helper utils (light stubs)
jest.mock('../../utils/documentHelper', () => ({
  mergeDocuments: (a: any, b: any) => [...a, ...b],
  updateDocsAfterUpload: (
    section: any,
    rfiDoc: any,
    _res: any,
    status: 'success' | 'failed'
  ) => {
    const docs =
      status === 'success'
        ? [...section.documents, { ...rfiDoc, id: rfiDoc.id || 'doc-1', location: 's3://x' }]
        : section.documents;
    return { ...section, documents: docs, status };
  },
  getCurrentSection: (_getState: any, section: any) => section,
  handleRfiError: (_e: any, setLoading: any, setErr: any) => {
    setLoading(false);
    setErr('error');
  },
  mapRfiRequestsToResponses: (reqs: any) => reqs,
  toRfiDocument: (file: File) => ({ name: file.name, originalFile: file }),
}));

// light stubs for child components (don’t test them here)
jest.mock('../../components/DocumentSectionCard', () => ({
  __esModule: true,
  default: (p: any) => (
    <div data-testid="doc-section">
      {p?.rfiItem?.requestid}
      <button onClick={() => p.onAttach?.([new File(['x'], 'x.pdf')])}>Upload</button>
      <button onClick={() => p.onRemove?.({ id: 'B1', name: 'b.pdf' })}>Delete</button>
    </div>
  ),
}));
jest.mock('../../components/TextDocumentSectionCard', () => ({
  __esModule: true,
  default: (p: any) => (
    <div data-testid="text-doc-section">
      {p?.rfiItem?.requestid}
      <button onClick={() => p.onComment?.('ok')}>comment</button>
      <button onClick={() => p.onAttach?.([new File(['y'], 'y.pdf')])}>UploadTD</button>
    </div>
  ),
}));
jest.mock('../../components/DocumentSidebar', () => ({
  __esModule: true,
  default: () => <aside data-testid="sidebar" />,
}));
jest.mock('../../shared/components/Loader', () => ({
  __esModule: true,
  default: () => <div data-testid="loader" />,
}));
jest.mock('../../components/ConfirmationDialogue', () => ({
  __esModule: true,
  default: ({ open, onCancel, onProceed, title }: any) =>
    open ? (
      <div data-testid="confirm">
        <div>{title}</div>
        <button onClick={onProceed}>Submit</button>
        <button onClick={onCancel}>Cancel</button>
      </div>
    ) : null,
}));
jest.mock('../../components/ThankYouScreen', () => ({
  __esModule: true,
  default: () => <div>Thank you!</div>,
}));

// slice action creators (so our tiny test reducer can respond)
jest.mock('../../store/rfiUploadSlice', () => ({
  setRfiResponses: (payload: any) => ({ type: 'rfi/SET', payload }),
  updateRfiResponse: (payload: any) => ({ type: 'rfi/UPDATE', payload }),
  setRfiFullyAnswered: (payload: any) => ({ type: 'rfi/FULL', payload }),
}));

// ui lib (if used)
jest.mock('@bendleap/react-ui', () => {
  const Any = (p: any) => <div {...p} />;
  return {
    __esModule: true,
    Box: Any,
    Grid: (p: any) => <div data-grid {...p} />,
    Flex: Any,
    Text: (p: any) => <span {...p} />,
    Button: (p: any) => <button {...p} />,
  };
});

// debounce immediate (prevents timing flakes)
jest.mock('lodash', () => ({
  ...jest.requireActual('lodash'),
  debounce: (fn: any) => {
    (fn as any).cancel = jest.fn();
    return fn;
  },
}));

/* ===================== import component AFTER mocks ===================== */
import Documents from '../Documents';

/* ============================ store helpers ============================ */
function buildStore(pre?: Partial<any>) {
  const rfiUpload = createSlice({
    name: 'rfiUpload',
    initialState: { responses: [], isRfiFullyAnswered: false, ...(pre?.rfiUpload || {}) },
    reducers: {},
    extraReducers: (builder) => {
      builder.addCase('rfi/SET' as any, (state: any, action: any) => {
        state.responses = action.payload;
      });
      builder.addCase('rfi/UPDATE' as any, (state: any, action: any) => {
        state.responses = state.responses.map((s: any) =>
          s.requestid === action.payload.requestid ? action.payload : s
        );
      });
      builder.addCase('rfi/FULL' as any, (state: any, action: any) => {
        state.isRfiFullyAnswered = action.payload;
      });
    },
  });

  const auth = createSlice({
    name: 'auth',
    initialState: { user: { email: 'user@example.com' }, ...(pre?.auth || {}) },
    reducers: {},
  });

  return configureStore({ reducer: { rfiUpload: rfiUpload.reducer, auth: auth.reducer } });
}

const RESPONSES = [
  {
    requestid: 'REQ-TEXT-DOC',
    requestType: 'TEXT_AND_DOCUMENT',
    category: 'KYC',
    answer: 'some text',
    documents: [{ id: 'A1', name: 'a.pdf', location: 's3://a' }],
    status: 'PENDING_ANSWERED',
  },
  {
    requestid: 'REQ-DOC',
    requestType: 'DOCUMENT',
    category: 'INCOME',
    answer: '',
    documents: [{ id: 'B1', name: 'b.pdf', location: 's3://b' }],
    status: 'PENDING_ANSWERED',
  },
];

function renderWith(store: any) {
  return render(
    <Provider store={store}>
      <Documents />
    </Provider>
  );
}

/* ================================ tests ================================ */
describe('<Documents />', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders header, sidebar and sections', async () => {
    const store = buildStore({ rfiUpload: { responses: RESPONSES } });
    renderWith(store);

    await waitFor(() => expect(mockGetRfi).toHaveBeenCalled());

    expect(await screen.findByText(/Documents and Information Collection/i)).toBeInTheDocument();
    expect(screen.getByTestId('sidebar')).toBeInTheDocument();
    expect(screen.getAllByTestId(/doc-section|text-doc-section/).length).toBeGreaterThan(0);
  });

  it('Save as Draft posts DRAFT payload', async () => {
    const store = buildStore({ rfiUpload: { responses: RESPONSES } });
    renderWith(store);

    await waitFor(() => expect(mockGetRfi).toHaveBeenCalled());

    fireEvent.click(screen.getByRole('button', { name: /save as draft/i }));

    await waitFor(() =>
      expect(mockPostRfiResponse).toHaveBeenCalledWith(
        expect.objectContaining({
          state: 'DRAFT',
          applicationId: 'APP123',
          isRfiFullyAnswered: false,
        })
      )
    );
    // snackbar text is rendered by our mock
    expect(screen.getByTestId('snackbar')).toHaveTextContent('Draft saved successfully.');
    expect(screen.getByTestId('snackbar')).toHaveAttribute('data-severity', 'success');
  });

  it('Submit flow calls SUBMIT and shows Thank you', async () => {
    const store = buildStore({ rfiUpload: { responses: RESPONSES } });
    renderWith(store);

    await waitFor(() => expect(mockGetRfi).toHaveBeenCalled());

    fireEvent.click(screen.getByRole('button', { name: /submit documents/i }));
    expect(await screen.findByTestId('confirm')).toBeInTheDocument();

    fireEvent.click(screen.getByText('Submit'));

    await waitFor(() =>
      expect(mockPostRfiResponse).toHaveBeenCalledWith(
        expect.objectContaining({
          state: 'SUBMIT',
          applicationId: 'APP123',
          isRfiFullyAnswered: true,
        })
      )
    );
    expect(await screen.findByText(/Thank you!/i)).toBeInTheDocument();
  });

  it('upload and delete trigger document service calls', async () => {
    const store = buildStore({ rfiUpload: { responses: RESPONSES } });
    renderWith(store);

    await waitFor(() => expect(mockGetRfi).toHaveBeenCalled());

    fireEvent.click(screen.getByText('Upload'));
    fireEvent.click(screen.getByText('UploadTD'));
    expect(mockUploadDocument).toHaveBeenCalled();

    fireEvent.click(screen.getAllByText('Delete')[0]);
    await waitFor(() => expect(mockDeleteDocument).toHaveBeenCalled());
  });
});
