
/* eslint-disable @typescript-eslint/no-explicit-any */
import MockAdapter from "axios-mock-adapter";
import HTTPService, {
  axiosInstance,
  requestInterceptor,
  setRefreshTokenHandler,
} from "./http.service";

// ---- Mock token storage used by the service ----
jest.mock("../utils/tokenStorage", () => {
  let token = "OLD_TOKEN";
  let exp: number | null = null;
  return {
    getAccessToken: jest.fn(() => token),
    setAccessToken: jest.fn((t: string) => (token = t)),
    setAccessTokenExpiry: jest.fn((e: number) => (exp = e)),
  };
});

const { getAccessToken, setAccessToken, setAccessTokenExpiry } =
  jest.requireMock("../utils/tokenStorage");

describe("http.service", () => {
  const http = new HTTPService();
  let mock: MockAdapter;

  beforeEach(() => {
    mock = new MockAdapter(axiosInstance);
    jest.clearAllMocks();
  });

  afterEach(() => {
    mock.restore();
  });

  test("requestInterceptor adds auth and custom headers", () => {
    (getAccessToken as jest.Mock).mockReturnValue("XYZ");

    const cfg: any = requestInterceptor({ url: "/x", headers: {} });
    expect(cfg.headers["ntb-token"]).toBe("Bearer XYZ");
    expect(cfg.headers["Authorization"]).toBe("Bearer XYZ");
    expect(cfg.headers["Content-Type"]).toBe("application/json");
    expect(cfg.headers["Financial-Id"]).toBe("EBI");
    expect(cfg.headers["Unique-Reference-Code"]).toMatch(/^NTBCP/);
    expect(cfg.headers["client-timestamp"]).toBeDefined();
  });

  test("passes through successful responses", async () => {
    mock.onGet("/ok").reply(200, { ok: true });

    const res = await http.get<{ ok: boolean }>("/ok");
    expect(res.status).toBe(200);
    expect(res.data.ok).toBe(true);
  });

  test("401 triggers refresh then retries original request", async () => {
    // First call 401, second succeeds
    mock.onGet("/secure").replyOnce(401, {});
    mock.onGet("/secure").reply(200, { data: "secured" });

    // Register a refresh handler
    setRefreshTokenHandler(async (_old: string) => {
      return { accessToken: "NEW_TOKEN", data: { expiresIn: 3600 } };
    });

    const res = await http.get<any>("/secure");

    expect(setAccessToken as jest.Mock).toHaveBeenCalledWith("NEW_TOKEN");
    expect(setAccessTokenExpiry as jest.Mock).toHaveBeenCalledWith(3600);
    expect(res.status).toBe(200);
    expect(res.data).toEqual({ data: "secured" });
  });

  test("refresh failure rejects with SESSION_EXPIRED", async () => {
    mock.onGet("/secure").replyOnce(401, {});
    // (wonâ€™t be reached) keep a fallback
    mock.onGet("/secure").reply(200, { data: "after-refresh" });

    setRefreshTokenHandler(async () => {
      throw new Error("refresh failed");
    });

    await expect(http.get("/secure")).rejects.toMatchObject({
      message: "SESSION_EXPIRED",
    });
  });

  test("non-401 error is serialized with cause", async () => {
    mock.onGet("/boom").reply(500, { err: "oops" });

    await expect(http.get("/boom")).rejects.toMatchObject({
      // message comes from axios message, but we mostly check `cause`
      cause: expect.objectContaining({
        status: 500,
        response: { err: "oops" },
        method: "get",
        url: "/boom",
      }),
    });
  });
});
